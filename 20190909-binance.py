#coding:utf-8

import hmac
import hashlib
import logging
import requests
import time
import math
import talib as ta

try:
    from urllib import urlencode

# for python3
except ImportError:
    from urllib.parse import urlencode


ENDPOINT = "https://www.binance.com"

BUY = "BUY"
SELL = "SELL"

LIMIT = "LIMIT"
MARKET = "MARKET"

GTC = "GTC"
IOC = "IOC"

options = {}


def set(apiKey, secret):
    """Set API key and secret.

    Must be called before any making any signed API calls.
    """
    options["apiKey"] = apiKey
    options["secret"] = secret


def prices():
    """Get latest prices for all symbols."""
    data = request("GET", "/api/v1/ticker/allPrices")
    return {d["symbol"]: d["price"] for d in data}


def tickers():
    """Get best price/qty on the order book for all symbols."""
    data = request("GET", "/api/v1/ticker/allBookTickers")
    return {d["symbol"]: {
        "bid": d["bidPrice"],
        "ask": d["askPrice"],
        "bidQty": d["bidQty"],
        "askQty": d["askQty"],
    } for d in data}


def depth(symbol, **kwargs):
    """Get order book.

    Args:
        symbol (str)
        limit (int, optional): Default 100. Must be one of 50, 20, 100, 500, 5,
            200, 10.

    """
    params = {"symbol": symbol}
    params.update(kwargs)
    data = request("GET", "/api/v1/depth", params)
    return {
        "bids": {px: qty for px, qty, _ in data["bids"]},
        "asks": {px: qty for px, qty, _ in data["asks"]},
    }


def klines(symbol, interval, **kwargs):
    """Get kline/candlestick bars for a symbol.

    Klines are uniquely identified by their open time. If startTime and endTime
    are not sent, the most recent klines are returned.

    Args:
        symbol (str)
        interval (str)
        limit (int, optional): Default 500; max 500.
        startTime (int, optional)
        endTime (int, optional)

    """
    params = {"symbol": symbol, "interval": interval}
    params.update(kwargs)
    data = request("GET", "/api/v1/klines", params)
    return [{
        "openTime": d[0],
        "open": d[1],
        "high": d[2],
        "low": d[3],
        "close": d[4],
        "volume": d[5],
        "closeTime": d[6],
        "quoteVolume": d[7],
        "numTrades": d[8],
    } for d in data]


def balances():
    """Get current balances for all symbols."""
    data = signedRequest("GET", "/api/v3/account", {})
    if 'msg' in data:
        raise ValueError("Error from exchange: {}".format(data['msg']))

    return {d["asset"]: {
        "free": d["free"],
        "locked": d["locked"],
    } for d in data.get("balances", [])}


def order(symbol, side, quantity, price, orderType=LIMIT, timeInForce=GTC,
          test=False, **kwargs):
    """Send in a new order.

    Args:
        symbol (str)
        side (str): BUY or SELL.
        quantity (float, str or decimal)
        price (float, str or decimal)
        orderType (str, optional): LIMIT or MARKET.
        timeInForce (str, optional): GTC or IOC.
        test (bool, optional): Creates and validates a new order but does not
            send it into the matching engine. Returns an empty dict if
            successful.
        newClientOrderId (str, optional): A unique id for the order.
            Automatically generated if not sent.
        stopPrice (float, str or decimal, optional): Used with stop orders.
        icebergQty (float, str or decimal, optional): Used with iceberg orders.

    """
    params = {
        "symbol": symbol,
        "side": side,
        "type": orderType,
        "timeInForce": timeInForce,
        "quantity": formatNumber(quantity),
        "price": formatNumber(price),
    }
    params.update(kwargs)
    path = "/api/v3/order/test" if test else "/api/v3/order"
    data = signedRequest("POST", path, params)
    return data


def orderStatus(symbol, **kwargs):
    """Check an order's status.

    Args:
        symbol (str)
        orderId (int, optional)
        origClientOrderId (str, optional)
        recvWindow (int, optional)

    """
    params = {"symbol": symbol}
    params.update(kwargs)
    data = signedRequest("GET", "/api/v3/order", params)
    return data


def cancel(symbol, **kwargs):
    """Cancel an active order.

    Args:
        symbol (str)
        orderId (int, optional)
        origClientOrderId (str, optional)
        newClientOrderId (str, optional): Used to uniquely identify this
            cancel. Automatically generated by default.
        recvWindow (int, optional)

    """
    params = {"symbol": symbol}
    params.update(kwargs)
    data = signedRequest("DELETE", "/api/v3/order", params)
    return data


def openOrders(symbol, **kwargs):
    """Get all open orders on a symbol.

    Args:
        symbol (str)
        recvWindow (int, optional)

    """
    params = {"symbol": symbol}
    params.update(kwargs)
    data = signedRequest("GET", "/api/v3/openOrders", params)
    return data


def allOrders(symbol, **kwargs):
    """Get all account orders; active, canceled, or filled.

    If orderId is set, it will get orders >= that orderId. Otherwise most
    recent orders are returned.

    Args:
        symbol (str)
        orderId (int, optional)
        limit (int, optional): Default 500; max 500.
        recvWindow (int, optional)

    """
    params = {"symbol": symbol}
    params.update(kwargs)
    data = signedRequest("GET", "/api/v3/allOrders", params)
    return data


def myTrades(symbol, **kwargs):
    """Get trades for a specific account and symbol.

    Args:
        symbol (str)
        limit (int, optional): Default 500; max 500.
        fromId (int, optional): TradeId to fetch from. Default gets most recent
            trades.
        recvWindow (int, optional)

    """
    params = {"symbol": symbol}
    params.update(kwargs)
    data = signedRequest("GET", "/api/v3/myTrades", params)
    return data


def request(method, path, params=None):
    resp = requests.request(method, ENDPOINT + path, params=params)
    data = resp.json()
    if "msg" in data:
        logging.error(data['msg'])
    return data


def signedRequest(method, path, params):
    if "apiKey" not in options or "secret" not in options:
        raise ValueError("Api key and secret must be set")

    query = urlencode(sorted(params.items()))
    query += "&timestamp={}".format(int(time.time() * 1000))
    secret = bytes(options["secret"].encode("utf-8"))
    signature = hmac.new(secret, query.encode("utf-8"),
                         hashlib.sha256).hexdigest()
    query += "&signature={}".format(signature)
    resp = requests.request(method,
                            ENDPOINT + path + "?" + query,
                            headers={"X-MBX-APIKEY": options["apiKey"]})
    data = resp.json()
    if "msg" in data:
        logging.error(data['msg'])
    return data


def formatNumber(x):
    if isinstance(x, float):
        return "{:.8f}".format(x)
    else:
        return str(x)

def servertime():
    """Get latest prices for all symbols."""
    data = request("GET", "/api/v1/time")
    return data

def wave():
    """Used for wave price case only
    new_buyQty = 50000  # 单次购买数量   100000 100000   50000  100000  50000
    profit_qty = 100  # 单次盈利HOT   300    200      100     100    50
    stop_eth = 3.2  # 预留ETH的量
    profit_step = 0.00000002  # 网格间隔  0.00000003  0.00000002 0.00000002 0.00000001 0.00000001
    sleep_time = 5
    """
    #new_sellQty = math.floor(new_buyQty * 0.999) - profit_qty
    buy_orderid = ''
    base_account = 6.65759135
    base_HOT = 9336200
    alph = 1
    new_buyQty = 10000 * alph  # 单次购买数量   100000 100000   50000  100000  50000
    profit_qty = 10 * alph  # 单次盈利HOT   300    200      100     100    50
    new_sellQty = math.floor(new_buyQty * 0.999) - profit_qty
    stop_eth = 3.6  # 预留ETH的量
    profit_step = 0.00000003  # 网格间隔  0.00000003  0.00000002 0.00000002 0.00000001 0.00000001
    sleep_time = 10

    # print(klines('HOTETH', '1m',startTime=1499040000000))
    # print(allOrders('HOTETH'))
    print(servertime())
    print(time.time()*1000)
    delt = time.time()*1000-servertime()['serverTime']
    print(delt)
    print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()), ' haiwwhaitest---------------------')

    while delt < 5000 and delt > -5000:
        try:
            mybalance = balances()
            myopen_orders = openOrders('HOTETH')
            mytickers = tickers()
            order_qty = len(myopen_orders)
            print('----------------------------------------------------------')
            # 测试区-------------------------------------------------

            # wave function 简要趋势判断，影响交易量
            total = klines('HOTETH', '1m')
            total2 = klines('HOTBTC', '1m')
            if buy_orderid !='' :
                if orderStatus('HOTETH', orderId=buy_orderid)['status'] == 'NEW' :
                    if float(total[len(total) - 1]['volume']) > 100000000 or float(
                            total2[len(total2) - 1]['volume']) > 100000000:
                        # big fly or drop
                        if float(total[len(total) - 1]['close']) - float(total[len(total) - 1]['open']) > 0:
                            # fly
                            alph = 3
                            new_buyQty = 10000 * alph  # 单次购买数量   100000 100000   50000  100000  50000
                            profit_qty = 5 * alph  # 单次盈利HOT   300    200      100     100    50
                            new_sellQty = math.floor(new_buyQty * 0.999) - profit_qty
                            stop_eth = 3.6  # 预留ETH的量
                            profit_step = 0.00000003  # 网格间隔  0.00000003  0.00000002 0.00000002 0.00000001 0.00000001
                            sleep_time = 3
                            print('----------------------------------------------------------')
                            print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()), 'Big Fly Case ↑ ↑ ↑ ↑ ↑ ↑.')

                        else:
                            # drop
                            alph = 0.3
                            new_buyQty = 10000 * alph  # 单次购买数量   100000 100000   50000  100000  50000
                            profit_qty = 10 * alph  # 单次盈利HOT   300    200      100     100    50
                            new_sellQty = math.floor(new_buyQty * 0.999) - profit_qty
                            stop_eth = 3.6  # 预留ETH的量
                            profit_step = 0.00000003  # 网格间隔  0.00000003  0.00000002 0.00000002 0.00000001 0.00000001
                            sleep_time = 20
                            print('----------------------------------------------------------')
                            print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()), 'Big Drop Case ↓ ↓ ↓ ↓ ↓ ↓.')

                    elif float(total[len(total) - 1]['volume']) > 10000000 or float(
                            total2[len(total2) - 1]['volume']) > 10000000:
                        # small fly or drop
                        if float(total[len(total) - 1]['close']) - float(total[len(total) - 1]['open']) >= 0:
                            # fly
                            alph = 2
                            new_buyQty = 10000 * alph  # 单次购买数量   100000 100000   50000  100000  50000
                            profit_qty = 3 * alph  # 单次盈利HOT   300    200      100     100    50
                            new_sellQty = math.floor(new_buyQty * 0.999) - profit_qty
                            stop_eth = 3.6  # 预留ETH的量
                            profit_step = 0.00000003  # 网格间隔  0.00000003  0.00000002 0.00000002 0.00000001 0.00000001
                            sleep_time = 5
                            print('----------------------------------------------------------')
                            print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()), 'Small Fly Case ↑ → ↑ → ↑ →.')

                        else:
                            # drop
                            alph = 0.5
                            new_buyQty = 10000 * alph  # 单次购买数量   100000 100000   50000  100000  50000
                            profit_qty = 10 * alph  # 单次盈利HOT   300    200      100     100    50
                            new_sellQty = math.floor(new_buyQty * 0.999) - profit_qty
                            stop_eth = 3.6  # 预留ETH的量
                            profit_step = 0.00000003  # 网格间隔  0.00000003  0.00000002 0.00000002 0.00000001 0.00000001
                            sleep_time = 10
                            print('----------------------------------------------------------')
                            print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()), 'Small Drop Case ↓ → ↓ → ↓ →.')

                    else:
                        alph = 1
                        new_buyQty = 10000 * alph  # 单次购买数量   100000 100000   50000  100000  50000
                        profit_qty = 10 * alph  # 单次盈利HOT   300    200      100     100    50
                        new_sellQty = math.floor(new_buyQty * 0.999) - profit_qty
                        stop_eth = 3.6  # 预留ETH的量
                        profit_step = 0.00000003  # 网格间隔  0.00000003  0.00000002 0.00000002 0.00000001 0.00000001
                        sleep_time = 2
                        print('----------------------------------------------------------')
                        print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()), 'Wave case ↖ ↙ ↗ ↘ ↑ ↓.')

            # ----------------------------------------------------------------
            #print('----------------------------------------------------------')
            print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()), 'HOT:', mybalance['HOT'], 'ETH:',
                  mybalance['ETH'])

            # 需增加0.01 eth 判断
            profit = float(mybalance['ETH']['free']) + float(mybalance['ETH']['locked']) + (
                        float(mybalance['HOT']['free']) + float(mybalance['HOT']['locked'])-base_HOT) * float(
                mytickers['HOTETH']['bid'])
            print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()), 'STATUS: ', mytickers['HOTETH']['ask'],
                  mytickers['HOTETH']['askQty'], mytickers['HOTETH']['bid'], mytickers['HOTETH']['bidQty'], profit,
                  '%.4f%%' % ((profit-base_account) / base_account * 100))

            #增加简单趋势判断==========================================

            # =======================================================
            if float(mybalance['ETH']['locked']) >= 0.01:  # 有买单挂单，看看目前价格是否取消
                print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()),
                      'Have locked ETH! Proceed to CHECK ask price!')
                order_qty = len(myopen_orders)

                for i in range(0, order_qty):
                    if myopen_orders[i]['side'] == 'BUY':
                        # print(i ,'Order Price:',  myopen_orders[i]['price'])
                        buy_orderid = myopen_orders[i]['orderId']
                        buy_price = myopen_orders[i]['price']

                # print('Ticker bid:',mytickers['HOTETH']['bid'])
                if float(mytickers['HOTETH']['bid']) > float(buy_price):
                    # 判断是否增加ticker价格的购买
                    # 如果金额不够，卖掉最低的
                    # print(buy_orderid)
                    if orderStatus('HOTETH', orderId=buy_orderid)['status'] == 'NEW':
                        print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()),
                              'Cancel BUY order, update to new price!')
                        cancel('HOTETH', orderId=buy_orderid)  # 先取消

                        if float(mybalance['ETH']['free']) > stop_eth:  # 止损 3 ETH
                            buy_orderid = order('HOTETH', 'BUY', new_buyQty, mytickers['HOTETH']['bid'])['orderId']
                        else:
                            print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()),
                                  'No enough balance! Please RECHARGE1!')

                    # 如果部分成交咋办 价格飞涨
                    elif orderStatus('HOTETH', orderId=buy_orderid)['status'] == 'PARTIALLY_FILLED':
                        cancel('HOTETH', orderId=buy_orderid)  # 先取消
                        print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()),
                              'Cancel PARTIALLY_BUY order, to SELL it ALL!')
                        mybalance = balances()  # 查询账户
                        mytickers = tickers()  # 再次查询  价格暴涨  不急
                        if float(mytickers['HOTETH']['bid']) > (
                                float(orderStatus('HOTETH', orderId=buy_orderid)['price']) + profit_step):
                            order('HOTETH', 'SELL', math.floor(float(mybalance['HOT']['free'])),
                                  float(mytickers['HOTETH']['bid']))
                        else:
                            order('HOTETH', 'SELL', math.floor(float(mybalance['HOT']['free'])),
                                  (float(orderStatus('HOTETH', orderId=buy_orderid)['price']) + profit_step))
                        print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()),
                              'Finish the HOT sell procedure, SELL ', math.floor(float(mybalance['HOT']['free'])), ' !')
                    else:
                        print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()),
                              'I am working, no change, just WAIT to the MOON2!')

                else:
                    # 判断是否  增加或者减少
                    print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()),
                          'I am working, no change, just WAIT to the MOON!')
                    # print(myopen_orders[len(myopen_orders)-1]['orderId'])
                    # print(allOrders('HOTETH',orderId = buy_orderid)[0])
                    # print(orderStatus('HOTETH',orderId=buy_orderid))

            else:  # 无挂单，准备买挂单，判断是否要卖的HOT
                if float(mybalance['HOT']['free']) >= profit_qty and buy_orderid != '':  # 刚买完 直接卖, 排除掉线后 重新启动
                    print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()), 'BUY HOT finish, proceed to SELL ',
                          new_sellQty, ' !')
                    # print('i am in',buy_orderid,orderStatus('HOTETH',orderId=buy_orderid)['status'])
                    # print(myopen_orders)
                    if orderStatus('HOTETH', orderId=buy_orderid)['status'] == 'FILLED':
                        # print(i ,'Order Price:',  myopen_orders[i]['price'])
                        if float(mytickers['HOTETH']['bid']) > (
                                float(orderStatus('HOTETH', orderId=buy_orderid)['price']) + profit_step):
                            order('HOTETH', 'SELL', new_sellQty, float(mytickers['HOTETH']['bid']))
                        else:
                            order('HOTETH', 'SELL', new_sellQty,
                                  (float(orderStatus('HOTETH', orderId=buy_orderid)['price']) + profit_step))
                        print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()),
                              'Finish the HOT sell procedure, SELL ', new_sellQty, ' !')

                    myopen_orders = openOrders('HOTETH')  # update order
                    order_qty = len(myopen_orders)
                    mybalance = balances()  # 查询账户
                    if float(mybalance['HOT']['free']) >= profit_qty:  # 有HOT余额才判断 卖出
                        print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()),
                              'CHECK the NEW profit and sell to 0.000009!')
                        for i in range(0, order_qty):
                            if myopen_orders[i]['side'] == 'SELL' and myopen_orders[i]['price'] == '0.00000900':
                                # print(i ,'Order Price:',  myopen_orders[i]['price'])
                                buy_orderid = myopen_orders[i]['orderId']
                                cancel('HOTETH', orderId=buy_orderid)  # 取消

                                mybalance = balances()  # 查询账户
                                order('HOTETH', 'SELL', math.floor(float(mybalance['HOT']['free'])), 0.00000900)
                                print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()),
                                      'SELL NEW profit to 0.000009 finish!')
                        buy_orderid = ''
                elif float(mybalance['HOT']['free']) >= 1:  # 以前卖了剩下的
                    print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()),
                          'CHECK the EXISTING profit and sell to 0.000009')
                    for i in range(0, order_qty):
                        if myopen_orders[i]['side'] == 'SELL' and myopen_orders[i]['price'] == '0.00000900':
                            # print(i ,'Order Price:',  myopen_orders[i]['price'])
                            buy_orderid = myopen_orders[i]['orderId']
                            cancel('HOTETH', orderId=buy_orderid)  # 取消

                            mybalance = balances()  # 查询账户
                            order('HOTETH', 'SELL', math.floor(float(mybalance['HOT']['free'])), 0.00000900)
                            print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()),
                                  'SELL EXISTING profit to 0.000009 finish 1!')

                        else:
                            mybalance = balances()  # 查询账户
                            order('HOTETH', 'SELL', math.floor(float(mybalance['HOT']['free'])), 0.00000900)
                            print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()),
                                  'SELL EXISTING profit to 0.000009 finish 2!')

                    buy_orderid = ''

                else:  # 啥单都么有，买挂单

                    print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()),
                          'No locked HOT and ETH! Proceed to BUY HOT!')  # 啥都没有，重新挂单
                    # 检查账户需要大于0.01
                    if float(mybalance['ETH']['free']) > stop_eth:  # 止损 3 ETH
                        buy_orderid = order('HOTETH', 'BUY', new_buyQty, mytickers['HOTETH']['bid'])['orderId']
                        print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()), 'PLACED NEW ORDER WITH ',
                              new_buyQty, ' HOT WITH ID ', buy_orderid, '!')
                    else:
                        print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()),
                              'No enough balance! Please RECHARGE2!')
                        # print(orderStatus('HOTETH',405940))

            time.sleep(sleep_time)
            # print(time.time()*1000-servertime()['serverTime'])

        except:
            print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()), 'Found some error, jump to next!')
            time.sleep(sleep_time)
    return "I am is running!"

#==================================================================================================================
'''
0.波动改成函数
1.增加趋势判断，调整策略；
1.1.如何判断横盘，上涨，下跌
2.目前的策略适合横盘策略
3.增加上涨判断，根据仓位选择买入或者卖出
4.跌的时候，采用斐波那契数列 买入  买入价格

'''


#自定义------------------------------------------------

#set API key
set("UipUOqgUhtsTVykBAEBGjR6ErvVojcaoDojPcH5YGSC4Lm855ZBjXNG39S2FP5Wf","4o7yqjr2q1MO5MFxMxwKnoQNjh5jBJP2fADBpMGUiDJW28bxivnq3v0Gaan4TkoD")

'''
1、判断是否有挂单
2、如果没有
3、如果有
'''
list = [1,2,3,5,8,13,21,34,55,89,144]
listQTY = [0,0,0,0,0,0,0,0,0,0,0]
base_account = 6.65759135
new_buyQty = 10000 #单次购买数量   100000 100000   50000  100000  50000
profit_qty = 10    #单次盈利HOT   300    200      100     100    50
stop_eth = 3.5   #预留ETH的量
profit_step = 0.00000003  #网格间隔  0.00000003  0.00000002 0.00000002 0.00000001 0.00000001
sleep_time = 15
#MACD 为正偏离加大 上涨  下穿偏离加大为  下跌  其他时间为 波动
#需判断偏离是加剧还是 减少
#
wave()

mybalance = balances()
print(mybalance['HOT']['locked'],"--" ,mybalance['HOT']['free'])
myopen_orders = openOrders('HOTETH')
mytickers = tickers()
profit = float(mybalance['ETH']['free']) + float(mybalance['ETH']['locked']) + (
        float(mybalance['HOT']['free']) + float(mybalance['HOT']['locked']) - 9336200) * float(
    mytickers['HOTETH']['bid'])
print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()), 'PROFIT: ', profit, ' STATUS: ', mytickers['HOTETH']['ask'],
      mytickers['HOTETH']['askQty'], mytickers['HOTETH']['bid'], mytickers['HOTETH']['bidQty'])




